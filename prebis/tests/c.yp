%{
#include "precomp.h"
#include "cfe_priv.h"

#include "c.tab.inc" // automatically generated definitions

#define YYINITDEPTH 50

#define YYDEBUG 1

#if YYDEBUG
#  define YYERROR_VERBOSE 1
#endif
#define YYSTDERR          stdout

// In order to prevent usage of last_line & last_column, we declare this to be
// empty
#define YYLLOC_DEFAULT(Current, Rhs, N) 

void yyerror ( char * err );
int yylex ( void );

static void yy_mark ( unsigned typ, const YYSTYPE * pval );

// Use this to fix bison type errors when we *really* don't have a result
// from a production.
#define NO_RESULT  ((void)0)

static TDeclSpecs * DSPECS_COMBINE ( TDeclSpecs * a, TDeclSpecs ** pb );
static TQualNode * DSPECS_GENQUAL ( TDeclSpecs ** pds );

%}

%union 
{
  STRING       str;
  TSymbol      * sym;
  TQualNode    * typ;
  CORD         cord;
  TAst         * ast;
  TDeclSpecs   * dspecs;
  int          token;
}

// type specifiers
//
%token<token> C_VOID C_CHAR C_SHORT C_INT C_LONG C_SIGNED C_UNSIGNED C_FLOAT C_DOUBLE
%token<token> C__BOOL C__COMPLEX C__IMAGINARY

// EXT: a general way to describe an extended integer type
%token C_EXT_INT
%token C_EXT_FLOAT

// type qualifiers
//
%token<token> C_CONST C_VOLATILE C_RESTRICT

// Storage classes
//
%token<token> C_EXTERN C_AUTO C_STATIC C_REGISTER C_TYPEDEF

%token C_INLINE

// C reserved words
//
%token SWITCH
%token STRUCT
%token CONTINUE
%token CASE
%token SIZEOF
%token DEFAULT
%token ELSE
%token WHILE
%token DO
%token ENUM
%token GOTO
%token BREAK
%token IF
%token FOR
%token UNION
%token RETURN

%token<str>  IDENT     // All identifiers that are not reserved words
%token<sym>  TYPENAME  // All identifiers that are typedefs in the current block

%token<ast>  NUMBER          // A numeric constant
%token<ast>  F_NUMBER        // A floating point constant
%token  STRING_CONST     // A string constant
%token  LSTRING_CONST    

// Punctuators longer than a character

%token LOG_OR LOG_AND INC DEC PTR ELLIPSIS 

// Identifiers that group similar tokens to simplify the grammar

%token  ASSIGN        // *= /= %= += -= &= |= ^= <<= >>=
%token  EQCOMPARE     // == !=
%token  ARITHCOMPARE  // <= >= < >
%token  SHIFT         // << >>

// __declspec
%token  DECLSPEC 

// a non-ansi attribute like __cdecl, __pascal, __far, __near
%token  ATTR

// EXT: GNU C extensions
//
%token TYPEOF LABEL ALIGNOF GCC_ATTRIBUTE

// Set precedences to avoid IF-ELSE `shift'/reduce conflict
%left   IF
%left   ELSE

/*
  3 `shift'/reduce conflicts on TYPENAME in declaration_specifiers. 
  1 `shift'/reduce conflicts on TYPENAME in specifier_qualifier_list
  They are explained in the source.
*/
%expect 4

%%

start:
    translation_unit { @1 }
  | /*empty*/
  ;


//--------------------------------------------------------------------------
// Name         garbage_collect
//
// Perform an incremental garbale collection while parsing.
//--------------------------------------------------------------------------
garbage_collect:
    {
      // Is it time to collect ?
      // In debug builds we always perform a full collection to make sure
      // there isn't a marking bug.
      //
#ifdef _DEBUG
      if (GcCollectStart( true )) 
#else
      if (GcCollectStart( false )) 
#endif
      {
        YY_MARK_STACK();   // mark the contents of the parser stack
        Cfe_GcMarkRoots(); // mark all C front-end data

        GcCollectEnd();
      }
    }
  ;


/////////////////////////////////////////////////////////////////
//
// Little helpers added by me
//


//  An optional ',' at the end of initializer_list/enumerator_list
comma_opt:
    /*empty*/
  | ','
  ;


/////////////////////////////////////////////////////////////////
//
//  A.1 Lexical elements
//


%type<ast> constant:
    NUMBER
  | F_NUMBER
/*
  | enumeration_constant
*/
  ;

string_literal:
    STRING_CONST
  | LSTRING_CONST
  | string_literal STRING_CONST
  | string_literal LSTRING_CONST
  ;

/*
  6.2.3  Name spaces of identifiers

  [#1] If more than one declaration of a particular identifier
  is visible at any point in a translation unit, the syntactic
  context disambiguates uses that refer to different entities.
  Thus,  there are separate name spaces for various categories
  of identifiers, as follows:

    -- label names (disambiguated by the syntax of  the  label
       declaration and use);

    -- the   tags  of  structures,  unions,  and  enumerations
       (disambiguated  by  following  any22)  of  the keywords
       struct, union, or enum);

    -- the members of structures or unions; each structure  or
       union  has  a  separate  name  space  for  its  members
       (disambiguated by the type of the  expression  used  to
       access the member via the . or -> operator);

    -- all  other  identifiers,  called  ordinary  identifiers
       (declared in ordinary  declarators  or  as  enumeration
       constants).
*/

// regular identifiers 
identifier:
    IDENT               {TODO;}
  ;

%type<str> any_identifier:
    TYPENAME   { $$ = $TYPENAME->id.strName }
  | IDENT
  ;

/////////////////////////////////////////////////////////////////
//
//  A.2.1 Expressions
//

// 6.5.1
%type<ast> primary_expression:
    identifier         {TODO;}
  | constant           
  | string_literal     {TODO;}
  | '(' expression ')' { $$ = $expression; }
// EXT: GNU C extension
  | '(' compound_statement ')'  {TODO;}
  ;

// 6.5.2
%type<ast> postfix_expression:
    primary_expression                                          
  | postfix_expression '[' expression ']'                       {TODO;}
  | postfix_expression '(' argument_expression_list_opt ')'     {TODO;}
  | postfix_expression '.' any_identifier                       {TODO;}
  | postfix_expression PTR any_identifier                       {TODO;}
  | postfix_expression INC                                      {TODO;}
  | postfix_expression DEC                                      {TODO;}
  | '(' type_name ')' '{' initializer_list comma_opt '}'        {TODO;}
  ;

argument_expression_list:
    assignment_expression                                       {TODO;}
  | argument_expression_list ',' assignment_expression          {TODO;}
  ;

argument_expression_list_opt:
    /*empty*/
  | argument_expression_list
  ;

// 6.5.3
%type<ast> unary_expression:
    postfix_expression
  | INC unary_expression              {TODO;}
  | DEC unary_expression              {TODO;}
  | unary_operator cast_expression    {TODO;}
  | SIZEOF unary_expression           {TODO;}
  | SIZEOF '(' type_name ')'          {TODO;}

// EXT: GNU C extensions
  | ALIGNOF unary_expression          {TODO;}
  | ALIGNOF '(' type_name ')'         {TODO;}
  | LOG_AND any_identifier            {TODO;}
  ;

unary_operator:
    '&' | '*' | '+' | '-' | '~' | '!'
  ;


// 6.5.4
%type<ast> cast_expression:
    unary_expression
  | '(' type_name ')' cast_expression  {TODO;}
  ;

// 6.5.5
%type<ast> multiplicative_expression:
    cast_expression
  | multiplicative_expression '*' cast_expression    {$$ = Expr_mul( &@1, $multiplicative_expression, $cast_expression )}
  | multiplicative_expression '/' cast_expression    {TODO;}
  | multiplicative_expression '%' cast_expression    {TODO;}
  ;

// 6.5.6
%type<ast> additive_expression:
    multiplicative_expression
  | additive_expression '+' multiplicative_expression    {TODO;}
  | additive_expression '-' multiplicative_expression    {TODO;}
  ;

// 6.5.7
%type<ast> shift_expression:
    additive_expression
  | shift_expression SHIFT additive_expression           {TODO;}
  ;

// 6.5.8
%type<ast> relational_expression:
    shift_expression 
  | relational_expression ARITHCOMPARE shift_expression  {TODO;}
  ;

// 6.5.9
%type<ast> equality_expression:
    relational_expression
  | equality_expression EQCOMPARE relational_expression  {TODO;}
  ;

// 6.5.10
%type<ast> and_expression:
    equality_expression
  | and_expression '&' equality_expression   {$$ = Expr_binAnd( &@2, $and_expression, $equality_expression )}
  ;

// 6.5.11
%type<ast> exclusive_or_expression:
    and_expression 
  | exclusive_or_expression '^' and_expression  {$$ = Expr_binXor( &@2, $exclusive_or_expression, $and_expression )}
  ;

// 6.5.12
%type<ast> inclusive_or_expression:
    exclusive_or_expression
  | inclusive_or_expression '|' exclusive_or_expression {$$ = Expr_binOr( &@2, $inclusive_or_expression, $exclusive_or_expression )}
  ;

// 6.5.13
%type<ast> logical_and_expression:
    inclusive_or_expression
  | logical_and_expression LOG_AND inclusive_or_expression  {TODO;}
  ;

// 6.5.14
%type<ast> logical_or_expression:
    logical_and_expression 
  | logical_or_expression LOG_OR logical_and_expression     {TODO;}
  ;

// 6.5.15
%type<ast> conditional_expression:
    logical_or_expression
// EXT: Omitting the expression is GNU C extension
  | logical_or_expression '?' expression_opt ':' conditional_expression {TODO;}
  ;

// 6.5.16
%type<ast> assignment_expression:
    conditional_expression
  | unary_expression assignment_operator assignment_expression  {TODO;}
  ;

assignment_expression_opt:
    /*empty*/
  | assignment_expression    {TODO;DumpAst( $assignment_expression );}
  ;

assignment_operator:
    ASSIGN | '='
  ;

// 6.5.17
%type<ast> expression1:
    assignment_expression
  | expression1 ',' assignment_expression     {TODO;}
  ;

%type<ast> expression:
    expression1 { DumpAst( $expression1 ) }
  ;

expression_opt:
    /*empty*/
  | expression                               {TODO;}
  ;

// 6.6
%type<ast> constant_expression1:
    conditional_expression
  ;

%type<ast> constant_expression:
    constant_expression1 { DumpAst( $constant_expression1 ) }
  ;



/////////////////////////////////////////////////////////////////
//
//  A.2.2 Declarations
//

/*
// EXT: GNU C Extension
//
// Note: may be this will be better done with a lexical hack.
// Perhaps that's the purpose of the double brackets anyway.
// 
gcc_attribute:
    GCC_ATTRIBUTE '(' '(' gcc_attribute_value_list ')' ')'
  ;

gcc_attribute_value_list:
    gcc_attribute_value
  | gcc_attribute_value_list ',' gcc_attribute_value
  ;

gcc_attribute_value:
    any_identifier
  ;

gcc_attribute_list_opt:
    //empty
  | gcc_attribute_list_opt gcc_attribute
  ;
*/

// 6.7
declaration:
    GenType_declaration_specifiers 
    init_declarator_list_opt( $GenType_declaration_specifiers ) ';'  
      {NO_RESULT} 
  ;

%type<dspecs> GenType_declaration_specifiers:
    declaration_specifiers { $$ = DSpecs_GenType( $declaration_specifiers ) }
  ;

/*
  This part must declare at least one specifier according
  to the C99 standard. For compatibilty with the older standard
  we allow declaration_specifiers without a signe specifier 
  (leading to declarations like "static i;"). We can enforce 
  the standard behaviour later semantically if we want.

  Note: this decision causes 3 `shift'/reduce conflicts on TYPENAME. 
  Is TYPENAME part of the specifiers or part of the declarator?
  The default behaviour (`shift') suits us since the TYPENAME must be
  part of the specifiers. 
*/

%type<dspecs> declaration_specifiers:
    storage_class_specifier declaration_specifiers_opt   { $$ = DSPECS_COMBINE( $storage_class_specifier, &$declaration_specifiers_opt ) }
  | function_specifier      declaration_specifiers_opt   { $$ = DSPECS_COMBINE( $function_specifier,      &$declaration_specifiers_opt ) }
  | type_qualifier          declaration_specifiers_opt   { $$ = DSPECS_COMBINE( $type_qualifier,          &$declaration_specifiers_opt ) }

  | type_specifier          declaration_specifiers1      { $$ = DSPECS_COMBINE( $type_specifier,          &$declaration_specifiers1 ) }
  | typedef_name            declaration_specifiers2      { $$ = DSPECS_COMBINE( $typedef_name,            &$declaration_specifiers2 ) }
  ;

%type<dspecs> declaration_specifiers_opt:
    /*empty*/                   { $$ = NULL }
  | declaration_specifiers
  ;

%type<dspecs> declaration_specifiers1:
    /*empty*/                                            { $$ = NULL }
  | storage_class_specifier declaration_specifiers1      { $$ = DSPECS_COMBINE( $storage_class_specifier, &$declaration_specifiers1 ) }
  | function_specifier      declaration_specifiers1      { $$ = DSPECS_COMBINE( $function_specifier,      &$declaration_specifiers1 ) }
  | type_qualifier          declaration_specifiers1      { $$ = DSPECS_COMBINE( $type_qualifier,          &$declaration_specifiers1 ) }
  | type_specifier          declaration_specifiers1      { $$ = DSPECS_COMBINE( $type_specifier,          &$declaration_specifiers1 ) }
  ;

%type<dspecs> declaration_specifiers2:
    /*empty*/                                            { $$ = NULL }
  | storage_class_specifier declaration_specifiers2      { $$ = DSPECS_COMBINE( $storage_class_specifier, &$declaration_specifiers2 ) }
  | function_specifier      declaration_specifiers2      { $$ = DSPECS_COMBINE( $function_specifier,      &$declaration_specifiers2 ) }
  | type_qualifier          declaration_specifiers2      { $$ = DSPECS_COMBINE( $type_qualifier,          &$declaration_specifiers2 ) }
  ;

init_declarator_list( $<dspecs>dspecs ): 
    init_declarator( $dspecs )
  | init_declarator_list( $dspecs ) ',' init_declarator( $dspecs )
  ;

init_declarator_list_opt( $<dspecs>dspecs ): 
    /*empty*/
  | init_declarator_list( $dspecs )
  ;

init_declarator( $<dspecs>dspecs ):  
    declarator( $dspecs )
  | declarator( $dspecs ) '=' initializer
  ;

// 6.7.1
%type<dspecs> storage_class_specifier:
    sclass                  { $$ = New_DSpecs( $sclass ) }
//EXT: our extension
  | declspec
  ;

%type<token> sclass:
    // EXT: Note: initialized typedef is a GNU C extension  
    C_TYPEDEF    
  | C_EXTERN
  | C_STATIC
  | C_AUTO
  | C_REGISTER
  ;


// EXT: Our extension
//
// attributes like DllImport,DllExport, or whatever the
// compiler/platform supports, are specified this way.
//
%type<dspecs> declspec:
    DECLSPEC '(' any_identifier ')'   {TODO}
  ;

%type<dspecs> declspec_list_opt:
    /*empty*/                           { $$ = NULL }
  | declspec_list_opt declspec        {TODO}
  ;

// 6.7.2

/*
  This is declaration is too loose.
  Each alternative can't be combined with any other alternative in 
  the same specifier list. Actually only typespec can be combined
  with itself

  So, we can put a few additional rules to prevent those things.

  To remove the conflicts we need to take care of the typedef_name only
  because it causes conflicts.
*/
%type<dspecs> type_specifier:
    typespec                   { $$ = New_DSpecs( $typespec ) }
  | extended_int_specifier
  | struct_or_union_specifier
  | enum_specifier

// EXT: GNU C extension
  | TYPEOF '(' expression ')'  {TODO}
  | TYPEOF '(' type_name ')'   {TODO}
  ; 

%type<token> typespec:
    C_VOID        
  | C_CHAR        
  | C_SHORT       
  | C_INT      
  | C_LONG     
  | C_SIGNED   
  | C_UNSIGNED  
  | C_FLOAT     
  | C_DOUBLE    
  | C__BOOL     
  | C__COMPLEX  
  | C__IMAGINARY  
  ;

// EXT: a general way to specify extended integer types
%type<dspecs> extended_int_specifier:
    C_EXT_INT '(' NUMBER ')'    {TODO}
  ;

// 6.7.2.1
// EXT: declspec is our extension
%type<dspecs> struct_or_union_specifier:
    struct_or_union declspec_list_opt any_identifier '{' struct_declaration_list '}'  {TODO}
  | struct_or_union declspec_list_opt                '{' struct_declaration_list '}'  {TODO}
  | struct_or_union declspec_list_opt any_identifier                                  {TODO}
  ;

struct_or_union:
    STRUCT 
  | UNION
  ;

struct_declaration_list:
    struct_declaration
  | struct_declaration_list struct_declaration
  ;

struct_declaration:
    GenType_specifier_qualifier_list struct_declarator_list( $GenType_specifier_qualifier_list ) ';' {TODO}
  ;

%type<dspecs> GenType_specifier_qualifier_list:
    specifier_qualifier_list { $$ = DSpecs_GenType( $specifier_qualifier_list ) }
  ;

/*
  This rule has one `shift'/reduce conflict on TYPENAME. 
  Is TYPENAME part of the specifier_qualifer_list or part of the declarator?

  It is part of specifier_qualifier_list, so `shift' is ok.
  See explanations at declaration_specifiers
*/
%type<dspecs> specifier_qualifier_list :
    type_qualifier specifier_qualifier_list    { $$ = DSPECS_COMBINE( $type_qualifier, &$specifier_qualifier_list ) }
  | type_qualifier 
  | type_specifier specifier_qualifier_list1   { $$ = DSPECS_COMBINE( $type_specifier, &$specifier_qualifier_list1 ) }
  | typedef_name   specifier_qualifier_list2   { $$ = DSPECS_COMBINE( $typedef_name,   &$specifier_qualifier_list2 ) }
  ;

%type<dspecs> specifier_qualifier_list1 :
    /*empty*/                                    { $$ = NULL }
  | type_qualifier specifier_qualifier_list1     { $$ = DSPECS_COMBINE( $type_qualifier, &$specifier_qualifier_list1 ) }
  | type_specifier specifier_qualifier_list1     { $$ = DSPECS_COMBINE( $type_specifier, &$specifier_qualifier_list1 ) }
  ;

%type<dspecs> specifier_qualifier_list2: // = dspecs
    /*empty*/                                    { $$ = NULL }
  | type_qualifier specifier_qualifier_list2     { $$ = DSPECS_COMBINE( $type_qualifier, &$specifier_qualifier_list2 ) }
  ;

struct_declarator_list( $<dspecs>dspecs ): 
    struct_declarator( $dspecs )
  | struct_declarator_list( $dspecs ) ',' struct_declarator( $dspecs )
  ;

struct_declarator( $<dspecs>dspecs ): 
    declarator( $dspecs )
  | declarator( $dspecs ) ':' constant_expression
  |                    ':' constant_expression
  ;

// 6.7.2.2
%type<dspecs> enum_specifier:
    ENUM any_identifier '{' enumerator_list comma_opt '}'   {TODO}
  | ENUM                '{' enumerator_list comma_opt '}'   {TODO}
  | ENUM any_identifier                                     {TODO}
  ;

enumerator_list:
    enumerator
  | enumerator_list ',' enumerator
  ;

enumerator:
    enumeration_constant
  | enumeration_constant '=' constant_expression
  ;

enumeration_constant:
    any_identifier      {TODO}
  ;

// 6.7.3
%type<dspecs> type_qualifier:
    qual       { $$ = New_DSpecs( $qual ) }

    // EXT: Our extension
    //
    // attribute like _far, _near, _cdecl, _pascal, or whatever the
    // compiler/platform supports are specified this way.
    //
  | ATTR '(' any_identifier ')'           {TODO}
  ;

%type<token> qual:
    C_CONST
  | C_RESTRICT
  | C_VOLATILE
  ;


// 6.7.4
%type<dspecs> function_specifier:
    C_INLINE           {TODO}
  ;

// 6.7.5

declarator( $<dspecs>dspecs ): 
    pointer_opt( $dspecs ) direct_declarator( $pointer_opt ) 
      {
        Declare( $direct_declarator );
      }
  ;

%type<dspecs> direct_declarator_tail( $<dspecs>dspecs ):
    '[' type_qualifier_list_opt assignment_expression_opt ']'
      {
        TTypeNode * tnode = New_TTypeNode( TYPE_ARRAY );
        tnode->of = $dspecs->type;
        tnode->u.arrayLen = $assignment_expression_opt;

        $$ = DSpecs_SetType( $dspecs, $type_qualifier_list_opt, tnode );
      }
  | '[' C_STATIC type_qualifier_list_opt assignment_expression ']'
  | '[' type_qualifier_list C_STATIC assignment_expression ']'
  | '[' type_qualifier_list_opt '*' ']'
  | '(' parameter_type_list ')'
  | '(' identifier_list_opt ')'
  ;

//--------------------------------------------------------------------------
// Name         left_bra_CopyDSpecs
//
// The "function" matches a left bracket '(' and returns its $<dspecs>dspecs parameter.
// 
// The purpose is to avoid parse conflicts in cases when we have to copy 
// the TYPE accross an open bracket. 
//
// The grammar originally has these rules somewhere:
//
//   a = '(' declarator ')'
//   b = '(' declarator2 ')'
//
// declarator and declarator2 need the $dspecs as it was passed to 'a' and 'b'.
// So, we modify the grammar:
//   a = '(' Push0(dspecs) declarator ')'
//   b = '(' Push0(dspecs) declarator2 ')'
// This however causes parse conflicts, which leads us to the current:
//   a = left_bra_CopyDSpecs declarator ')'
//   b = left_bra_CopyDSpecs declarator2 ')'
//--------------------------------------------------------------------------
%type<dspecs> left_bra_CopyDSpecs( $<dspecs>dspecs ): 
    '(' { $$ = $dspecs }
  ;

%type<dspecs> direct_declarator( $<dspecs>dspecs ):
    any_identifier  
      { 
        $$ = DSpecs_SetIdent( $any_identifier );
      }
  | left_bra_CopyDSpecs( $dspecs ) declarator( $left_bra_CopyDSpecs ) ')' 
      {
        $$ = $declarator;
      }
  | direct_declarator( $dspecs ) direct_declarator_tail( $direct_declarator )
      { 
        $$ = $direct_declarator_tail;
      }
  ;

/*
  declarator1 doesn't allow a TYPENAME in brackets.
  It is used only for parameter declaration where a TYPENAME in brackets
  would mean a function header.
  To achieve this goal, it redirects to declarator2 after the first bracket.
*/
declarator1( $<dspecs>dspecs ): 
    pointer_opt( $dspecs ) direct_declarator1( $pointer_opt )
      {
        Declare( $direct_declarator1 );
      }
  ;

%type<dspecs> direct_declarator1( $<dspecs>dspecs ):
    any_identifier
      { 
        $$ = DSpecs_SetIdent( $any_identifier );
      }
  | left_bra_CopyDSpecs( $dspecs ) declarator2( $left_bra_CopyDSpecs ) ')'
      {
        $$ = $declarator2;
      }
  | direct_declarator1( $dspecs ) direct_declarator_tail( $direct_declarator1 )
      { 
        $$ = $direct_declarator_tail;
      }
  ;

declarator2( $<dspecs>dspecs ): 
    pointer_opt( $dspecs ) direct_declarator2( $pointer_opt )
      {
        Declare( $direct_declarator2 );
      }
  ;

%type<dspecs> direct_declarator2( $<dspecs>dspecs ):
    identifier
      { 
        $$ = DSpecs_SetIdent( $identifier );
      }
  | left_bra_CopyDSpecs( $dspecs ) declarator2( $left_bra_CopyDSpecs ) ')'
      {
        $$ = $declarator2;
      }
  | direct_declarator2( $dspecs ) direct_declarator_tail( $direct_declarator2 )
      { 
        $$ = $direct_declarator_tail;
      }
  ;


//--------------------------------------------------------------------------
// Name         qual_pointer
//
// Allocate a qualified pointer and make it point to $typ
//--------------------------------------------------------------------------
%type<dspecs> qual_pointer( $<dspecs>dspecs ): 
    '*' type_qualifier_list_opt 
      { 
        TTypeNode * tnode = New_TTypeNode( TYPE_POINTER );
        tnode->of = $dspecs->type;

        $$ = DSpecs_SetType( $dspecs, $type_qualifier_list_opt, tnode );
      }
  ;

%type<dspecs> pointer( $<dspecs>dspecs ): 
    qual_pointer( $dspecs )           
  | pointer( $dspecs ) qual_pointer( $pointer )  { $$ = $qual_pointer }
  ;

%type<dspecs> pointer_opt( $<dspecs>dspecs ): 
    /*empty*/             { $$ = $dspecs }
  | pointer( $dspecs )               
  ;

%type<dspecs> type_qualifier_list:
    type_qualifier
  | type_qualifier_list type_qualifier   { $$ = DSPECS_COMBINE( $type_qualifier_list, &$type_qualifier ) }
  ;

%type<typ> type_qualifier_list_opt:
    /*empty*/              { $$ = DSpecs_GenQual( NULL ) }
  | type_qualifier_list    { $$ = DSPECS_GENQUAL( &$type_qualifier_list ) }
  ;


// EXT: this is a GNU C extension
// TODO: We ignore it for now, for the sake of implementing something.
forward_parameter_decl:
    /* declaration_specifiers declarator_list ';' */
  ;

/*
declarator_list( $<typ>typ ):  
    declarator 
  | declarator_list ',' {$$ = $0} declarator
  ;
*/

// EXT: forward_parameter_decl is a GNU C extension
parameter_type_list:
    forward_parameter_decl parameter_list
  | forward_parameter_decl parameter_list ',' ELLIPSIS
  ;

parameter_type_list_opt:
    /*empty*/
  | parameter_type_list
  ;

parameter_list:
    parameter_declaration
  | parameter_list ',' parameter_declaration
  ;

parameter_declaration:
    GenType_declaration_specifiers declarator1( $GenType_declaration_specifiers )         {TODO}
  | GenType_declaration_specifiers abstract_declarator( $GenType_declaration_specifiers ) {TODO}
  | GenType_declaration_specifiers                                                        {TODO}
  ;

/*
  In a identifier list (old-style parameter list)
  all but the first identifier can redefine a typedef. 
  (If the first one was a typedef then we would assume that this
  is a new style declaration).

  Both VC and BCC behave in this way. Theoretically there might be a way
  to fix this, perhaps with LR(2)?
*/
identifier_list:
    identifier
  | identifier_list ',' any_identifier
  ;

identifier_list_opt:
    /*empty*/
  | identifier_list
  ;

// 6.7.6
type_name:
    GenType_specifier_qualifier_list abstract_declarator( $GenType_specifier_qualifier_list ) {TODO}
  | GenType_specifier_qualifier_list                                                          {TODO}
  ;

abstract_declarator( $<dspecs>dspecs ): 
    pointer( $dspecs )                                                {TODO}
  | pointer_opt( $dspecs ) direct_abstract_declarator( $pointer_opt ) {TODO}
  ;

direct_abstract_declarator( $<dspecs>dspecs ):
    left_bra_CopyDSpecs( $dspecs ) abstract_declarator( $left_bra_CopyDSpecs ) ')'  {TODO}
  | direct_abstract_declarator( $dspecs ) '[' assignment_expression_opt ']'
  |                                    '[' assignment_expression_opt ']'
  | direct_abstract_declarator( $dspecs ) '[' '*' ']'
  |                                    '[' '*' ']'
  | direct_abstract_declarator( $dspecs ) '(' parameter_type_list_opt ')'
  |                                    '(' parameter_type_list_opt ')'
      
  ;

// 6.7.7
%type<dspecs> typedef_name:
    TYPENAME      {TODO1("Save the typedef itself"); /*$$ = New_DSpecs( $1 );*/}
  ;

// 6.7.8
initializer:
    assignment_expression                {TODO;}
  | '{' initializer_list comma_opt '}'
  ;

initializer_list:
    designation_opt initializer
  | initializer_list ',' designation_opt initializer
  ;

designation:
    designator_list '='
  ;

designation_opt:
    /*empty*/
  | designation
  ;

designator_list:
    designator
  | designator_list designator
  ;

designator:
    '[' constant_expression ']'
  | '.' any_identifier

// EXT: GNU C extensions
  | '[' constant_expression ELLIPSIS constant_expression ']'
//TODO(ifpossible): | any_identifier ':'
  ;

/////////////////////////////////////////////////////////////////
//
//  A.2.3 Statements
//


// 6.8
statement:
    labeled_statement
  | compound_statement
  | expression_statement
  | selection_statement
  | iteration_statement
  | jump_statement
  ;

// 6.8.1
labeled_statement:
    any_identifier ':' statement            {TODO}
  | CASE constant_expression ':' statement
  | DEFAULT ':' statement

// GNU C Extension
  | CASE constant_expression ELLIPSIS constant_expression ':' statement
  ;

// 6.8.2
compound_statement:
    '{' declare_labels_list_opt block_item_list_opt '}'
  ;

// EXT: This is a GNU C extension
//
declare_labels_list:
    declare_labels ';'
  | declare_labels_list declare_labels ';'
  ;

declare_labels_list_opt:
    /*empty*/
  | declare_labels_list
  ;

declare_labels:
    LABEL any_identifier
  | declare_labels ',' any_identifier
  ;

block_item_list:
    block_item
  | block_item_list block_item
  ;

block_item_list_opt:
    /*empty*/
  | block_item_list
  ;

block_item:
    declaration
  | statement
  ;

// 6.8.3
expression_statement:
    expression_opt ';'
  ;

// 6.8.4
selection_statement:
    IF '(' expression ')' statement                  %prec IF
  | IF '(' expression ')' statement ELSE statement   %prec ELSE
  | SWITCH '(' expression ')' statement
  ;

// 6.8.5
iteration_statement:
    WHILE '(' expression ')' statement
  | DO statement WHILE '(' expression ')' ';'
  | FOR '(' expression_opt ';' expression_opt ';' expression_opt ')' statement
  | FOR '(' declaration expression_opt ';' expression_opt ')' statement
  ;

// 6.8.6
jump_statement:
    GOTO any_identifier ';'
// EXT: GNU C extension
  | GOTO '*' cast_expression ';'
  
  | CONTINUE ';'
  | BREAK ';'
  | RETURN expression_opt ';'
  ;


/////////////////////////////////////////////////////////////////
//
//  A.2.4 External definitions
//

// 6.9
translation_unit:
    external_declaration 
      garbage_collect
  | translation_unit external_declaration
      garbage_collect
  ;

external_declaration:
    function_definition
  | declaration

// EXT: Non-ANSI extension: allow an empty file scope statement
  | ';'
  ;

// 6.9.1
function_definition:
    GenType_declaration_specifiers declarator( $GenType_declaration_specifiers ) 
      declaration_list_opt compound_statement {TODO}
  ;

declaration_list:
    declaration
  | declaration_list declaration
  ;

declaration_list_opt:
    /*empty*/
  | declaration_list
  ;

%%

// DSpecs manipulation routines, with explicitly freeing the no-longer used 
// argument to conserve memory. 
// Note: we need to zero the parser stack location that holds the 
// freed value.

//--------------------------------------------------------------------------
// Name         DSPECS_COMBINE 
//
// 
//--------------------------------------------------------------------------
static TDeclSpecs * DSPECS_COMBINE ( TDeclSpecs * a, TDeclSpecs ** pb )
{
  TDeclSpecs * res = DSpecs_Add( a, *pb );
  GC_DELETE( *pb );
  return res;
};

//--------------------------------------------------------------------------
// Name         DSPECS_GENQUAL 
//
// 
//--------------------------------------------------------------------------
static TQualNode * DSPECS_GENQUAL ( TDeclSpecs ** pds )
{
  TQualNode * res = DSpecs_GenQual( *pds );
  GC_DELETE( *pds );
  return res;
}

//--------------------------------------------------------------------------
// Name         yy_mark 
//
// Mark the contents of a semantic stack entry (YYSTYPE).
//
// _typ_ identifies the type of the entry, corresponing to a member
// of the declared %union. The possible values of _typ_ (YYST_xxx) are 
// generated automatically by PREBIS and are defined in c.tab.inc
//--------------------------------------------------------------------------
static void yy_mark ( unsigned typ, const YYSTYPE * pval )
{
  switch (typ)
  {
  case YYST_AST:
    GC_MARK( pval->ast ); break;

  case YYST_STR:
    GC_MARK( pval->str ); break;

  case YYST_TOKEN:
    break;

  case YYST_SYM:
    GC_MARK( pval->sym ); break;

  case YYST_TYP:
    GC_MARK( pval->typ ); break;

  case YYST_DSPECS:
    GC_MARK( pval->dspecs ); break;

  default:
    ASSERT( 0 );
  }
}


#ifndef TEST_YYPARSE

void yyerror ( char * err )
{
  CompilerError( "%s", err );
};

#else

void yyerror ( char * err )
{
  printf( "\n\n **** error: %s\n\n", err );
};

int yylex ( void )
{
  int res;
  char buf[32];
  for(;;)
  {
    printf( "Enter code:" );
    gets( buf );

    if (isdigit(buf[0]))
    {
      if (sscanf( buf, "%d", &res ) != 1)
        printf( "Error! Try again.\n" );
      else
        return res;
    }
    else
    if (isalpha( buf[0] ))
    {
      int i;
      for ( i = 0; yytname[i] != NULL; ++i )
      {
        if (_stricmp( buf, yytname[i] ) == 0)
          return i + 255;
      }
      printf( "Undefined token! Try again.\n" );
    }
    else
      return buf[0];
  }
};

int main ( int argc, char ** argv )
{
#if YYDEBUG
  yydebug = argc == 2;
#endif 
  yyparse();

  return 0;
};
#endif // TEST_YYPARSE
