void yygen_typdefs ( void )
{
  int i;

  printf( "\n\n#ifndef %s\n\n", yytypstrs[0] );

  for ( i = 0; yytypstrs[i] != 0; ++i )
    printf( "#define %s  %u\n", yytypstrs[i], i + 1 );

  printf( "#define YYST__LAST  %u\n", i + 1 );
  printf( "\n#endif\n\n" );
};

void yygen_toktyp ( void )
{
  int tok, sym;

  printf( "#ifndef YYTOKTYP_DEFINED\n" );
  printf( "#define YYTOKTYP_DEFINED\n\n" );

  printf( "static const unsigned char yytoktyp[] = \n{\n" );
  printf( "  0, 0, 0" );

  for ( tok = 3; yytname[tok] != 0; ++tok )
  {
    printf( ", " );
    if (tok % 5 == 0)
      printf( "\n  " );

    for ( sym = 0; yytoktyp_str[sym][0] != 0; ++sym )
      if (strcmp(yytoktyp_str[sym][0], yytname[tok]) == 0)
        break;

    if (yytoktyp_str[sym][2] == 0)
      printf( "0" );
    else
      printf( "%s", yytoktyp_str[sym][2] );
  }

  printf( "\n};\n" );

  printf( "\n#endif\n\n" );
}

void yyprint_str ( const char * s )
{
  printf( "\"" );
  for ( ;*s; ++s )
  {
    switch (*s)
    {
    case '"': 
    case '\\': printf( "\\" ); break;

    case '\n': printf( "\\n" ); continue;
    case '\t': printf( "\\t" ); continue;
    case '\v': printf( "\\v" ); continue;
    }

    printf( "%c", *s );
  }
  printf( "\"" );
}


void yygen_tokdesc ( void )
{
  int tok, sym;

  printf( "#ifndef YYTOKDESC_DEFINED\n" );
  printf( "#define YYTOKDESC_DEFINED\n\n" );

  printf( "static const char * const yytokdesc[] = \n{\n" );
  printf( "  0, 0, 0" );

  for ( tok = 3; yytname[tok] != 0; ++tok )
  {
    printf( ", " );
    if (tok % 5 == 0)
      printf( "\n  " );

    for ( sym = 0; yytoktyp_str[sym][0] != 0; ++sym )
      if (strcmp(yytoktyp_str[sym][0], yytname[tok]) == 0)
        break;

    if (yytoktyp_str[sym][1] == 0)
      printf( "0" );
    else
      yyprint_str( yytoktyp_str[sym][1] );
  }

  printf( "\n};\n" );

  printf( "\n#endif\n\n" );
}


int latok[YYNSTATES]; // token or nonterminal shifted on stack before entering   
                      // a state

const char * getruletype ( int rule )
{
  switch (rule)
  {
#include YYACT
  }

  return 0;
}

const char * getsymtype ( int sym )
{
  int i;
  const char * typ;

  // First try to locate the symbol in the type table
  //
  for ( i = 0; yytoktyp_str[i][0] != 0; ++i )
  {
    if (strcmp( yytoktyp_str[i][0], yytname[sym] ) == 0)
      return yytoktyp_str[i][2];
  }

  // It is probably an internal symbol for an in-rule action. If the 
  // action was generated by PREBIS, it must have inserted code to return
  // its type.
  //
  // Reverse lookup in the rule->symbol table to determine the rule number.
  //
  for ( i = 0; i < sizeof(yyr1)/sizeof(yyr1[0]); ++i )
  {
    if (yyr1[i] == sym)
    {
      if (0 != (typ = getruletype( i )) )
        return typ;
    }
  }

  return 0;
}

void setlatok ( int state, int tok )
{
  if (latok[state] >= 0 && latok[state] != tok)
  {
    fprintf( stderr, "Conflict in state %d!!!\n", state );
    abort();
  }
  else
    latok[state] = tok;
}


void yygen_statetyp ( void )
{
  int state;

  // Clear the lookahead array
  //
  for ( state = 0; state < YYNSTATES; ++state )
    latok[state] = -1;

  // Iterate through the transition table for each state
  //
  for ( state = 0; state < YYNSTATES; ++state )
  {
    int tok1, ntsym, newstate;

    // Try every possible (translated) token
    //

    for ( tok1 = 0; tok1 < YYNTOKENS; ++tok1 )
    {
      int yyn;

      yyn = yypact[state] + tok1;
      if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != tok1)
      {
      }  
      else 
      {
        int action = yytable[yyn];

        if (action > 0) // a shift to a new state -> record the token!
        {
          newstate = action;

          setlatok( newstate, tok1 );
        }
      }
    }

    // Try every possible non-terminal
    //

    for ( ntsym = YYNTBASE; ntsym < YYNTBASE + YYNNTS; ++ntsym )
    {
      int t;

      t = yypgoto[ntsym - YYNTBASE] + state;
      if (t >= 0 && t <= YYLAST && yycheck[t] == state)
        newstate = yytable[t];
      else
        newstate = yydefgoto[ntsym - YYNTBASE];

      setlatok( newstate, ntsym );
    }
  }

  printf( "\n\n" );
  printf( "#ifndef YYSTATETYP_DEFINED\n" );
  printf( "#define YYSTATETYP_DEFINED\n\n" );
  printf( "static const unsigned char yystatetyp[] =\n{\n" );
  printf( "  0,\n" );

  // Generate the table (excluding state 0)
  //
  for ( state = 1; state < YYNSTATES; ++state )
  {
    const char * typ;
    int tok1;

    if (latok[state] < 0)
    {
      fprintf( stderr, "Error: state %d has no lookahead!\n", state ); 
      abort();
    }

    tok1 = latok[state];

    if (0 == (typ = getsymtype( tok1 )) )
    {
      //fprintf( stderr, "Warning: state %d (%s) has no type\n", state, yytname[tok1] ); 
      typ = "0";
    }

    printf( "  %s,", typ );
    printf( " \t/* %3d:%s */", state, yytname[tok1] );
    printf( "\n" );
  }
  printf( "};\n" );
  printf( "\n#endif\n\n" );
}

int main ( void )
{
  yygen_typdefs();
  yygen_toktyp();
  yygen_tokdesc();
  yygen_statetyp();
  return 0;
}

